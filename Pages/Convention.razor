@page "/convention"
<PageTitle>Coding Convention</PageTitle>

<MudContainer MaxWidth="MaxWidth.Large" Class="my-8">
    <MudText Typo="Typo.h3" Color="Color.Primary" Align="Align.Center" Class="mb-12" Style="text-shadow: 0 0 10px #39ff14;">
        [ CONVENTION ]
    </MudText>

    <CodeBox Title="Coding Convention (C#)" GithubUrl="https://github.com/ReltyWorks/TechJournal/blob/main/CodingConvention/CodingConvention.cs" >
    C# Coding Convention
        (The 6th New Vegas Conference)
    Finalized Date: 2225-12-12

    본 Coding Convention은 제6차 뉴베가스 회의(The 6th New Vegas Conference)에서
    협회장 '미스터 하우스(Mr. House)'와 빅 마운틴 연구 개발 센터(Big Mountain Research & Development Center)의
    싱크탱크 장 '모비우스 박사(Dr. Mobius)'에 의해 정립 되었다.

    이 표준안은 같은 싱크탱크 소속의 저명한 학자 5인(a.k.a. Robode Monkeys)에 의해 철저한 감수를 거쳐 승인되었다.

    --------------------------------------------------------------------------------

    # 00. 코딩하며 생각할 것

    ## 00-A. 코드에도 '단락'을 만들자 (공백 원칙)

    <strong>"서로 관련된 코드끼리 묶고, 의미의 전환이 일어날 때 한 줄을 비워준다."</strong>

    글을 쓸 때 하나의 주제가 끝나고 다음 주제로 넘어갈 때 문단을 나누는 것과 똑같다.
    코드의 가독성은 코드의 흐름을 얼마나 쉽게 읽을 수 있는지에 따라 결정된다.
    논리적인 코드 덩어리를 하나의 '단락'으로 취급하고, 단락 사이에 공백을 넣어 시각적으로 구분하면 코드를 훨씬 이해하기 쉬워진다.

    ## 00-B. 좋은 주석의 원칙

    <strong>"주석은 '무엇(What)'을 하는지가 아니라, '왜(Why)' 그렇게 했는지를 설명해야 한다."</strong>

    코드는 그 자체로 '무엇'을 하는지 이미 설명하고 있다.
    주석은 코드가 설명하지 못하는 배경, 의도, 그리고 이유를 보충하는 역할을 해야 한다.

    ### <strong>Bad</strong> : i++; // i를 1 증가시킨다.
        (코드를 그냥 한글로 번역한 수준)

    ### <strong>Good</strong> : i++; // 다음 아이템을 가리키기 위해 인덱스를 수동으로 조정.
        (왜 i를 증가시켜야만 하는지에 대한 '의도'를 설명)

    --------------------------------------------------------------------------------

    # 01. 멤버 및 타입 선언 규칙

    ## 01-A. 접근 지정자 명시 (IDE0040) (기본값에 의존하지 않음)
    클래스, 구조체 등의 상위 타입과 필드, 메서드, 프로퍼티 등 모든 멤버의 접근 지정자는 생략하지 않고 <strong>반드시 명시</strong>합니다.

    ### <strong>Bad</strong> :
        class Player          // internal 생략됨
        {
            int hp;           // private 생략됨
            void Attack() { } // private 생략됨
        }

    ### <strong>Good</strong> :
        internal class Player
        {
            private int hp;
            public void Attack() { }
        }

    ## 01-B. 타입의 명명 규칙
    모든 타입(클래스, 구조체, 인터페이스, 열거형 등)의 이름은 <strong>파스칼 케이스(PascalCase)</strong>로 작성합니다.
    각 단어의 첫 글자는 대문자이며, 단어 사이에 밑줄(_)이나 공백이 들어가지 않습니다.
    메서드, 프로퍼티, 이벤트 등도 동일하게 파스칼 케이스를 사용합니다.

    필드의 경우 <strong>카멜 케이스(camelCase)</strong>를 사용합니다.
    첫 글자는 소문자이며, 이후 단어의 첫 글자는 대문자로 작성하며 공백은 사용하지 않습니다.

    프라이빗 필드의 경우, 가독성을 위해 접두사로 밑줄(_)을 붙입니다.
    상수는 모두 대문자로 작성하며, 단어 사이에 밑줄(_)을 사용합니다.

    ## 01-C. 타입의 작명 규칙
    타입의 이름은 그 역할과 책임을 명확히 드러내는 단어로 구성합니다.
    축약형이나 약어는 피하고, 가능한 한 구체적인 의미를 담도록 합니다.
    예를 들어, `DataManager`보다는 `UserDataManager`가 더 구체적이고 명확한 이름입니다.

    이로 인해 코드가 너무 길어진다면, 메서드 내에서 지역 변수로 축약형을 사용할 수 있습니다.
    예를 들어, `UserDataManager` 타입의 인스턴스를 `udm`으로 참조하는 것은 허용됩니다.

    --------------------------------------------------------------------------------

    # 02. Boolean (불리언) 처리 규칙

    ## 02-A. 불리언 비교 시 동어반복(Redundancy) 금지
    조건문에서 `true`를 명시적으로 비교하지 않습니다.
    `true`인 상황에서는 불리언 변수 그 자체를 평가합니다.
    단, <strong>부정(false)을 체크하는 경우</strong>에는 예외적으로 명시적 비교를 허용 및 권장합니다(02-C 참조).

    ### <strong>Bad</strong> :
        if (isValid == true)
            return;

    ### <strong>Good</strong> :
        if (isValid)
            return;

    ## 02-B. 긍정형 변수명 사용 (부정의 부정 방지)
    변수명은 항상 <strong>긍정</strong>의 의미로 작성합니다.
    `isNot...`과 같은 부정형 이름은 `!isNot...` (부정의 부정) 상황을 만들어 가독성을 해칩니다.

    ### <strong>Bad</strong> :
        bool isNotFound, bool isNotFinished

    ### <strong>Good</strong> :
        bool isFound, bool isFinished

    ## 02-C. 부정 연산자(!) 지양 및 명시적 비교 (== false)
    부정 연산자(!)는 크기가 작아 식별하기 어렵고,
    IDE의 자동 정렬 기능이 연산자 뒤의 공백을 강제로 제거하여 가독성을 해칠 수 있습니다.
    따라서 부정 조건을 검사할 때는 <strong>! 대신 == false</strong>를 사용하여 의도를 명확히 하고 가독성을 확보합니다.

    ### <strong>Bad</strong> :
        if (!isDead)   // 식별하기 어려움
        if (! isDead)  // IDE 포매터가 공백을 강제로 삭제함

    ### <strong>Good</strong> :
        if (isDead == false) // 부정의 의미가 명확하며, 포매팅 간섭 없음

    --------------------------------------------------------------------------------

    # 03. 초기화 및 호출 규칙

    ## 03-A. 배열/리스트 초기화 시 'Single Source of Truth' 준수
    초기화 목록(Initializer list)이 있는 경우, 크기(Length)를 명시적으로 적지 않습니다.
    데이터의 개수(진실의 원천)는 중괄호 {} 안의 내용물이므로, 대괄호[] 안에 숫자를 적어 중복 정의하지 않습니다.

    ### <strong>Bad</strong> :
        private int[] ages = new int[5] { 10, 11, 12, 13, 14 };
        // 5라고 썼는데 실제 데이터가 4개거나 6개면 컴파일 에러 혹은 혼동 유발

    ### <strong>Good</strong> :
        private int[] ages = new int[] { 10, 11, 12, 13, 14 };
        // 또는
        private int[] ages = { 10, 11, 12, 13, 14 };

    ## 03-B. 인자 3개 이상 호출 시 '이름 지정 인수(Named Arguments)' 사용
    함수 호출 시 인자가 3개 이상 넘어갈 경우, 가독성과 실수를 방지하기 위해 매개변수 이름을 명시합니다.

    ### <strong>Bad</strong> :
        CreateUser("Jane", 25, "Seoul", true); // 각 인자가 무엇을 의미하는지 파악 어려움

    ### <strong>Good</strong> :
        CreateUser(name: "Jane",
                   age: 25,
                   address: "Seoul",
                   isActive: true);

    --------------------------------------------------------------------------------

    # 04. 타입 추론(var, new)을 통한 보일러플레이트 제거 (IDE0007, IDE0090)

    ## 04-A. 타입 추론 활용
    <strong>"같은 타입명이 한 줄에 두 번 등장하는 경우"</strong>에 한하여,
    타입 추론(var 또는 Target-typed new)을 사용하여 중복을 제거합니다.
    단, 메서드 이름만으로 타입을 유추할 수 있더라도, 선언부와 할당부의 타입이 명확히 중복될 때만 적용합니다.

    ### <strong>Bad</strong> (불필요한 반복) :
        Dictionary&lt;string, int&gt; scores = new Dictionary&lt;string, int&gt;();

    ### <strong>Good</strong> (Target-typed new 사용) :
        Dictionary&lt;string, int&gt; scores = new();

    ### <strong>Bad</strong> (불명확한 타입) :
        var message = GetString();

    ### <strong>Good</strong> (var 사용) :
        var scores = new Dictionary&lt;string, int&gt;();

    --------------------------------------------------------------------------------

    # 05. 제어문 블록 규칙 (Control Flow Block Rules)

    if, for, foreach 등의 제어문을 사용할 때, 가독성을 최우선으로 하여 줄바꿈과 블록({}) 사용 규칙을 정의합니다.

    ## 05-A. 단일 행의 처리 (Single Line)
    제어문의 본문이 단 한 줄일 경우, 중괄호({})를 생략할 수 있습니다.
    단, 조건식과 같은 줄에 붙여 쓰지 않고 <strong>반드시 줄을 바꿔 들여쓰기</strong>합니다.

    ### <strong>Bad</strong> (같은 줄 작성) :
        if (! isValid) return;

    ### <strong>Good</strong> (개행 후 작성) :
        if (! isValid)
            return;

    ## 05-B. 블록의 일관성 (Block Consistency)
    if-else if-else 체인에서, 연결된 조건문 중 <strong>단 하나라도</strong> 중괄호를 사용하는 블록(2줄 이상)이 있다면,
    나머지 모든 블록에도 중괄호를 적용하여 시각적 균형을 맞춥니다.

    ### <strong>Bad</strong> (불균형) :
        if (isDay)
            light.Off();          // 괄호 없음
        else
        {
            light.On();           // 괄호 있음 (시각적 부조화)
            monster.Spawn();
        }

    ### <strong>Good</strong> (균형 유지) :
        if (isDay)
        {
            light.Off();
        }
        else
        {
            light.On();
            monster.Spawn();
        }

    ## 05-C. 독립된 제어문 간의 공백
    서로 논리적으로 연결되지 않은(else로 묶이지 않은) 독립적인 제어문 사이에는, 한 줄의 공백을 넣어 구분합니다.
    이는 문맥의 전환을 시각적으로 알리기 위함입니다.

    ### <strong>Good</strong> :
    if (! isAlive)
        return;

    if (isPoisoned)
    {
        ApplyDamage();
        return;
    }

    --------------------------------------------------------------------------------
    
    # 06. 줄바꿈 및 포매팅 규칙 (Line Wrapping)
    
    가독성을 해치는 가로 스크롤을 방지하고, 코드의 논리적 흐름을 명확히 하기 위해 줄바꿈 규칙을 준수합니다.
    
    ## 06-A. 물리적 한계선 (100자 규칙)
    한 줄의 길이는 <strong>최대 100자(Column limit: 100)</strong>를 넘기지 않는 것을 원칙으로 합니다.
    100자가 넘어가는 코드는 가독성을 위해 반드시 적절한 위치에서 줄바꿈을 해야 합니다.
    IDE(Visual Studio 등)의 가이드라인 기능을 활용하여 이 선을 시각적으로 인지하도록 합니다.
    
    ## 06-B. 줄바꿈의 위치 (연산자 우선 원칙)
    줄을 바꿀 때는 연산자(+, -, and, or, .)의 <strong>앞에서</strong> 끊어줍니다.
    연산자가 줄의 끝에 남으면, 다음 줄을 보기 전까지 문장이 끝난 것인지 연결되는 것인지 파악하기 어렵습니다.
    연산자를 다음 줄의 시작 부분에 배치하여 <strong>"이 코드는 윗줄과 이어집니다"</strong>라는 사실을 명확히 알립니다.
    
    ### <strong>Bad</strong> (연산자를 뒤에 남김) :
        var totalScore = baseScore + bonusScore + 
                         eventScore;  // +가 잘 안 보일 수 있음
    
    ### <strong>Good</strong> (연산자로 시작함) :
        var totalScore = baseScore + bonusScore
                         + eventScore;
    
    ## 06-C. 메서드 체이닝(Method Chaining) 정렬
    LINQ나 빌더 패턴 등 메서드가 연속(Chaining)될 때 줄바꿈이 필요하다면,
    <strong>점(.)을 기준으로 줄을 바꾸고 들여쓰기를 맞춥니다.</strong>
    이때 점(.)은 다음 줄의 가장 앞에 위치시킵니다.
    
    ### <strong>Bad</strong> :
        var attribute = fieldInfo.GetCustomAttribute&lt;BindAttribute&gt;(
            ); // 괄호만 덩그러니 있거나, 점의 위치가 애매함
    
    ### <strong>Good</strong> :
        BindAttribute bindAtt = fieldInfo
                               .GetCustomAttribute&lt;BindAttribute&gt;(); 
                               // 윗줄의 시작점이나 논리적 흐름에 맞춰 정렬

    --------------------------------------------------------------------------------

    # 07. 클래스 멤버 작성 순서 (Class Layout)

    클래스 내부의 멤버들은 <strong>가급적 아래 순서(1~8)</strong>를 준수하여 작성합니다.
    이는 코드의 탐색 비용을 줄이고, 중요한 정보(공개 인터페이스)를 상단에 배치하기 위함입니다.

    ## 07-A. 작성 순서 가이드
    1.  프로퍼티 (Properties) : 외부와 소통하는 데이터 접근 통로를 최상단에 둡니다.
    2.  공개 필드 (Public Fields) : <strong>사용을 지양</strong> 하며 프로퍼티로 대체하는 것을 권장합니다.
        부득이하게 존재할 경우 프로퍼티 바로 아래 배치합니다.
    3.  비공개 필드 (Private Fields) : 내부 상태 저장을 위한 필드입니다.
    4.  생성자 (Constructors) : 객체 생성 및 초기화 로직입니다.
    5.  유니티 생명주기 메서드 (Unity Lifecycle Methods) :
        작성 원칙 : 호출되는 순서대로 작성하여 실행 흐름을 파악하기 쉽게 합니다.
        순서 예시 : Awake > OnEnable > Start > FixedUpdate > Update > ... > OnDisable > OnDestroy
    6.  공개 메서드 (Public Methods) :
        주요 로직 : 가장 자주 사용될 것으로 추정되는 핵심 메서드를 먼저 배치합니다.
        관용적 순서 : `Add` / `Remove`, `Start` / `Stop`와 같이 짝을 이루거나 관습적인 순서가 있다면 따릅니다.
    7.  비공개 메서드 (Private Methods) : 공개 메서드의 양에 따라 유연하게 정렬합니다.
        Case A (공개 메서드가 많을 때) : 자주 호출되는(의존성이 높은) 순서대로 정렬하여 중요도를 나타냅니다.
        Case B (공개 메서드가 적을 때) : 코드 흐름상 등장하는(호출되는) 순서대로 정렬하여 읽는 흐름을 끊지 않습니다.
    8.  영역 구분 (#region) : 코드가 비대해져 가독성이 떨어질 경우, #region을 사용하여 아래 규칙에 따라 묶는 것을 권장합니다.
        데이터 영역 : 프로퍼티, 공개 필드, 비공개 필드를 하나로 묶습니다.
        초기화 영역 : 생성자와 유니티 생명주기 메서드(Awake, Start 등)를 하나로 묶습니다.
        기능별 영역 : 특정 기능(예: 전투, UI)과 관련된 메서드들이라면, 공통 특성끼리 묶는 것을 허용합니다. 이 경우, 
                     리전 내부에서는 접근 지정자(public/private) 순서보다 기능적 흐름을 우선하여 순서를 섞을 수 있습니다.


    ## 07-B. 예시 코드 (Example)
    public class Player
    {
        #region Data Fields

        // 1. 프로퍼티 (Properties)
        public string Name { get; set; }
        public int Level { get; private set; }

        // 2. 공개 필드 (Public Fields) - 가급적 사용 지양
        public string legacyTag;

        // 3. 비공개 필드 (Private Fields)
        private int _hp;
        private int _mp;

        #endregion

        // ------------------------------

        #region Initialization & Lifecycle

        // 4. 생성자 (Constructors)
        public Player(string name)
        {
            Name = name;
            _hp = 100;
        }

        // 5. 유니티 생명주기 (호출 순서 준수)
        private void Awake()
        {
            _hp = 100;
        }
    
        private void OnEnable()
        {
            // 이벤트 구독 등
        }
    
        private void Start()
        {
            // 초기화 로직
        }

        #endregion

        // ------------------------------

        // 6. 공개 메서드 (Public Methods)
        // - 핵심 동작이나 관용적 순서(Equip -&gt; UnEquip) 우선
        public void Attack()
        {
            if (CanAttack())
            {
                // ...
            }
        }

        // ------------------------------

        #region Combat Feature (기능별 묶음 예시)

        // 8. 기능별 영역 사용 시 : Public/Private을 섞어서 흐름 위주로 배치 가능
        
        public void Equip(string item) 
        { 
            ValidateItem(item);
            // 장착 로직 
        }
    
        private void ValidateItem(string item)
        {
            // 장착 가능 여부 체크 (Private이지만 흐름상 여기에 위치)
        }
    
        public void UnEquip(string item) { /* ... */ }

        #endregion

        // ------------------------------

        // 7. 비공개 메서드 (Private Methods)
        // - 공개 메서드가 적으므로, 위 코드에서 호출되는(등장하는) 순서대로 배치
        private bool CanAttack()
        {
            return _hp &gt; 0;
        }

        // ... 기타 비공개 메서드 ...
    }
    </CodeBox>

</MudContainer>
